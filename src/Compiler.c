#include "core/EulToken.h"
#include "Compiler.h"
#include "core/ErrorTypes.h"

#include "Compiler.Functions.h"



#include <stdio.h>
#include <stdlib.h>

#define YYSTYPE EulToken*
#define YY_DECL int yylex(YYSTYPE * yylval_param, void* yyscanner, Compiler *compiler)
#include "parser/autoGenerated.EulSyntax.h"
#include "lexer/autoGenerated.EulLexer.h"





//region LIFE CYCLE
void Compiler_init(Compiler* this, char* entryPoint, FILE* (*onGetFile)(char* path), void (*onError)(Compiler* this)) {
  //1. setup callbacks
  this->onGetFile = onGetFile;
  this->onError = onError;

  //2. Init error variables
  this->errorCode = ErrorType_NO_ERROR;
  this->errorMessage = 0;

  //3. Init string buffer
  this->stringBuffer = (char*) malloc(1024);
  this->stringBufferLength = 1024;
  this->stringBufferIndex = 0;

  //4, setup the parser
  yylex_init(&this->scanner);
  this->currentSource = 0;

  //5. setup program
  EulProgram_init(&this->program, entryPoint);
}


void Compiler_deinit(Compiler* this) {
  EulProgram_deinit(&this->program);
  yylex_destroy(this->scanner);
  free(this->stringBuffer);
}

void Compiler_reset(Compiler* this, char* entryPoint) {
  //reset variables
  this->errorCode = ErrorType_NO_ERROR;
  this->errorMessage = 0;
  this->stringBufferIndex = 0;
  this->currentSource = 0;

  //reset program
  EulProgram_deinit(&this->program);
  EulProgram_init(&this->program, entryPoint);
}
//endregion





//region GETTERS
//endregion



//region LEXER RELATED ACTIONS
void Compiler_addToStringBuffer(Compiler *this, char ch) {
  if (this->stringBufferIndex >= this->stringBufferLength) Compiler_expandBuffer(this);
	this->stringBuffer[ this->stringBufferIndex++ ] = ch;
}

void Compiler_expandBuffer(Compiler *this) {
  //1. create a new buffer
  unsigned int newLength = this->stringBufferLength * 2;
  char* newBuffer = (char*) malloc(newLength);
  strncpy(newBuffer, this->stringBuffer, this->stringBufferLength);

  //2. destroy the old buffer
  free(this->stringBuffer);

  //3. Update this
  this->stringBuffer = newBuffer;
  this->stringBufferLength = newLength;
}
//endregion


//region API
/*
  Looks in the Program for thr next source file and compiles it.
  It returns 1 if a file was compiled, 0 if no more files are present,
  or in case of error
*/
int Compiler_compileNextSource(Compiler *this) {
  //1. get next source file.
  EulToken* tok = EulProgram_nextPendingSource(&this->program);
  if (tok==0) return 0;

  //2. check type and setup currentSource
  if (tok->type != EulTokenType_SOURCE_FILE) {
    Compiler_makeSemanticError(this, "Compiler excepcted token Source File");
    return 0;
  }
  this->currentSource = tok->value.asSourceFile;

  //2. get the FILE out of it:
  FILE* f = this->onGetFile( this->currentSource->id ); //id is the absolute path.
  if (f==0) {
    Compiler_makeFileNotFoundError(this, this->currentSource->id);
    return 0;
  }

  //3. Setup the scanner
  yyrestart( f, this->scanner );
	yyset_lineno(1, this->scanner);

  //4, Parse the file!
  yyparse(this->scanner, this);

  //5. Done. mark the file as Parsed
  this->currentSource->isParsed = 1;
  return 1;
}
//endregion



//region ERROR RELATED ACTIONS
void Compiler_makeLexerError(Compiler *this, char* message) {
  this->errorCode = ErrorType_LEXER;
  this->errorMessage = message;
  if (this->onError != 0) this->onError(this);
}


void Compiler_makeFileNotFoundError(Compiler *this, char* message) {
  this->errorCode = ErrorType_FILE_NOT_FOUND;
  this->errorMessage = message;
  if (this->onError != 0) this->onError(this);
}


void Compiler_makeSemanticError(Compiler *this, char* message) {
  this->errorCode = ErrorType_SEMANTIC;
  this->errorMessage = message;
  if (this->onError != 0) this->onError(this);
}


void Compiler_clearError(Compiler *this) {
  this->errorCode = ErrorType_NO_ERROR;
  this->errorMessage = 0;
}
//endregion
