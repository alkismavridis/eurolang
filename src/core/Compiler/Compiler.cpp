#include <string>
#include <forward_list>
#include <vector>
#include <map>

#include "../EulToken/EulTokenType.h"
#include "../EulToken/EulToken.h"
#include "../EulToken/EulIdToken.h"

#include "../EulAst/EulStatement/EulStatementType.h"
#include "../EulAst/EulAstType.h"
#include "../EulAst/EulAst.h"
#include "../EulAst/EulStatement/EulStatement.h"
#include "../EulAst/EulStatement/EulImportStatement.h"
#include "../EulAst/EulStatement/EulExportStatement.h"
#include "../EulAst/EulDeclaration/VarDeclaration.h"

#include "../EulSourceFile/EulSourceFile.h"
#include "../EulProgram/EulProgram.h"

#include "Compiler.h"
#include "../../constants/Constants.h"

#include "../../__autoGenerated__/EulParser.tab.hh"
#include "../../lexer/EulScanner.h"



//region LIFE CYCLE
Compiler::Compiler(void (*onError)(Compiler* ths)) {
  //1. setup callbacks
  this->onError = onError;

  //2. Init error variables
  this->errorCode = ErrorType_NO_ERROR;

  //4. setup the parser
  this->currentSource = nullptr;
}


void Compiler::reset() {
  //reset variables
  this->errorCode = ErrorType_NO_ERROR;
  this->errorMessage.clear();
  this->buffer.clear();
  this->currentSource = 0;

  //reset program
  this->program = EulProgram();
}
//endregion




//region API
/**
    This assumes that target is one of this.program.sources elements.
    input is the actual file.
    This function does NOT check the existence of the file. This should be done
    by the caller function.
*/
void Compiler::compile(EulSourceFile *target, std::istream *input) {
    //1. Update currentSource
    this->currentSource = target;

    //2. Setup a scanner and a parser
    EulParsingContext ctx(this, target);
    EulScanner scanner(input);
    yy::EulParser parser(scanner, &ctx);

    //3. Parse the source file
    parser.parse();

    //4. Done. mark the file as Parsed
    this->currentSource->isParsed = 1;
}

/**
    Convenience method. Accepts a file name instead of an EulSourceFile.
    Has the same effect as its counterpart compile(EulSourceFile *target, std::istream *input).
*/
void Compiler::compile(const std::string& sourceName, std::istream *input) {
    EulSourceFile* sourceFile = this->program.getSource(sourceName, true);
    this->compile(sourceFile, input);
}
//endregion




//region ERROR RELATED ACTIONS
void Compiler::makeLexerError(const std::string& message) {
  this->errorCode = ErrorType_LEXER;
  this->errorMessage.assign(message);
  if (this->onError != 0) this->onError(this);
}

void Compiler::makeFileNotFoundError(const std::string& message) {
  this->errorCode = ErrorType_FILE_NOT_FOUND;
  this->errorMessage.assign(message);
  if (this->onError != 0) this->onError(this);
}

void Compiler::makeSemanticError(const std::string& message) {
  this->errorCode = ErrorType_SEMANTIC;
  this->errorMessage.assign(message);
  if (this->onError != 0) this->onError(this);
}

void Compiler::clearError() {
  this->errorCode = ErrorType_NO_ERROR;
  this->errorMessage.clear();
}
//endregion
