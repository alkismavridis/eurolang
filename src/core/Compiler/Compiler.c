#include <stdio.h>
#include <stdlib.h>

#include "../EulNodeList/EulNodeList.h"
#include "../EulSourceFile/EulSourceFile.h"
#include "../EulProgram/EulProgram.h"
#include "../EulToken/EulToken.h"
#include "Compiler.h"
#include "../../constants/Constants.h"




#define YYSTYPE EulToken*
#define YY_DECL int yylex(YYSTYPE * yylval_param, void* yyscanner, Compiler *compiler)
#include "../../parser/autoGenerated.EulSyntax.h"
#include "../../lexer/autoGenerated.EulLexer.h"





//region LIFE CYCLE
void Compiler_init(Compiler* this, void (*onError)(Compiler* this)) {
  //1. setup callbacks
  this->onError = onError;

  //2. Init error variables
  this->errorCode = ErrorType_NO_ERROR;
  this->errorMessage = 0;

  //3. Init string buffer
  this->stringBuffer = (char*) malloc(1024);
  this->stringBufferLength = 1024;
  this->stringBufferIndex = 0;

  //4, setup the parser
  yylex_init(&this->scanner);
  this->currentSource = 0;

  //5. setup program
  EulProgram_init(&this->program);
}


void Compiler_deinit(Compiler* this) {
  EulProgram_deinit(&this->program);
  yylex_destroy(this->scanner);
  free(this->stringBuffer);
}

void Compiler_reset(Compiler* this) {
  //reset variables
  this->errorCode = ErrorType_NO_ERROR;
  this->errorMessage = 0;
  this->stringBufferIndex = 0;
  this->currentSource = 0;

  //reset program
  EulProgram_deinit(&this->program);
  EulProgram_init(&this->program);
}
//endregion




//region LEXER RELATED ACTIONS
void Compiler_addToStringBuffer(Compiler *this, char ch) {
  if (this->stringBufferIndex >= this->stringBufferLength) Compiler_expandBuffer(this);
	this->stringBuffer[ this->stringBufferIndex++ ] = ch;
}

void Compiler_expandBuffer(Compiler *this) {
  //1. create a new buffer
  unsigned int newLength = this->stringBufferLength * 2;
  char* newBuffer = (char*) malloc(newLength);
  strncpy(newBuffer, this->stringBuffer, this->stringBufferLength);

  //2. destroy the old buffer
  free(this->stringBuffer);

  //3. Update this
  this->stringBuffer = newBuffer;
  this->stringBufferLength = newLength;
}
//endregion




//region API
/**
    This assumes that target is one of this.program.sources elements.
    file is the actual file.
    This function does NOT check the existence of the file. This should be done
    by the caller function.
*/
void Compiler_compile(Compiler *this, EulSourceFile *target, FILE* file) {
  //1. Update currentSource
  this->currentSource = target;

  //2. Setup the scanner
  yyrestart( file, this->scanner );
  yyset_lineno(1, this->scanner);

  //3. Parse the file!
  yyparse(this->scanner, this);

  //4. Done. mark the file as Parsed
  this->currentSource->isParsed = 1;
}
//endregion




//region ERROR RELATED ACTIONS
void Compiler_makeLexerError(Compiler *this, char* message) {
  this->errorCode = ErrorType_LEXER;
  this->errorMessage = message;
  if (this->onError != 0) this->onError(this);
}

void Compiler_makeFileNotFoundError(Compiler *this, char* message) {
  this->errorCode = ErrorType_FILE_NOT_FOUND;
  this->errorMessage = message;
  if (this->onError != 0) this->onError(this);
}

void Compiler_makeSemanticError(Compiler *this, char* message) {
  this->errorCode = ErrorType_SEMANTIC;
  this->errorMessage = message;
  if (this->onError != 0) this->onError(this);
}

void Compiler_clearError(Compiler *this) {
  this->errorCode = ErrorType_NO_ERROR;
  this->errorMessage = 0;
}
//endregion
