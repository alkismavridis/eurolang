#include <stdlib.h>
#include "EulToken.h"
#include "../Compiler.h"

#define YYSTYPE EulToken*
#define YY_DECL int yylex(YYSTYPE * yylval_param, void* yyscanner, Compiler *compiler)
#include "../parser/autoGenerated.EulSyntax.h"



//region NODE
void EulNode_push(EulNode* this, EulToken* value) {
  this->next = malloc( sizeof(EulNode) );
  this->next->next = 0;
  this->next->value = value;
}
//endregion




//region NODE LIST
void EulNodeList_init(EulNodeList* this) {
  this->first = 0;
  this->last = 0;
}

void EulNodeList_push(EulNodeList* this, EulToken* value) {
  //create a node
  EulNode* newNode = malloc(sizeof(EulNode));
  newNode->value = value;

  //update first element, if needed
  if (this->first==0) this->first = newNode;

  //update the last element, adding the node on the list
  if (this->last!=0) this->last->next = newNode;
  this->last = newNode;
}


/** Returns the length of this list. */
int EulNodeList_length(EulNodeList* this) {
  int ret = 0;
  EulNode* current = this->first;
  while(current) {
    ret++;
    current = current->next;
  }

  return ret;
}

/**
  frees memory resources for all nodes on the list.
  IMPORTANT NOTE: it does NOT frees or deinits the tokens themselves.
*/
void EulNodeList_deinitAllNodes(EulNodeList* this) {
  EulNode* current = this->first;
  while(current) {
    EulNode* next = current->next;
    free(current);
    current = next;
  }
}
//endregion




//region BASIC TYPES
/**
  We must free only the token types that we allocated values for.
  Please note that not all tokenTypes have values.
  Also, some values include further mallocs besides the value itself.
*/
void EulToken_deinit(EulToken* this) {
  switch(this->type) {
    case EulTokenType_ID:
      free(this->value.asId);
      free(this); //TODO remove this
      break;

    case EulTokenType_STRING:
      free(this->value.asString);
      free(this); //TODO remove this
      break;

    case EulTokenType_CHAR:
    case EulTokenType_INT:
    case EulTokenType_FLOAT:
      free(this); //TODO remove this
      return;
  }
}
//endregion




//region TERMINALS
EulToken* EulToken_initInt(EulToken* this, char* text) {
  this->type = EulTokenType_INT;

	this->value.asInt.value = strtoul(text, &text, 10);		//setup value
	if (*text) { //setup signed or unsigned flag
		this->value.asInt.isUnsigned = (*text) == 'u';
		text++;
	}
	else this->value.asInt.isUnsigned = 0; //default is signed

	if (*text) this->value.asInt.size = strtoul(text, &text, 10);	//setup size, if any
	else this->value.asInt.size = EUL_LANG_DEFAULT_INT_SIZE;

	return this;
}


EulToken* EulToken_newFloat(char* text) {
  EulToken* this = malloc(sizeof(EulToken));
  this->type = EulTokenType_FLOAT;

	this->value.asFloat.value = strtod(text, &text);
	if (*text == 'f') text++; //skip f character, if any

	if (*text) this->value.asFloat.size = strtoul(text, &text, 10);
	else this->value.asFloat.size = EUL_LANG_DEFAULT_FLOAT_SIZE;

	return this;
}


EulToken* EulToken_newId(char* text, unsigned int len) {
  EulToken* this = malloc(sizeof(EulToken));
  this->type = EulTokenType_ID;

	//1. Setup string for id name
	this->value.asId = malloc(len+1); //this must be freed by EulToken_deinit
	strcpy(this->value.asId, text);
	return this;
}

EulToken* EulToken_newSimpleChar(char* text, unsigned int len, Compiler *compiler) {
  EulToken* this = malloc(sizeof(EulToken));
  this->type = EulTokenType_CHAR;

	this->value.asInt.size = len - 2; //we default the char size to its UTF length. We substract 2, because there are the '' quotes.

	switch(len) {
		case 3: //1 byte unicode
			this->value.asInt.value = (unsigned char) ( *(text+1) );
			break;

		case 4: //2 byte unicode
			this->value.asInt.value = ((unsigned char)text[1])<<8 | (unsigned char)text[2];
			break;

		case 6: //4 byte unicode
			this->value.asInt.value = ((unsigned char)text[1])<<24 | ((unsigned char)text[2])<<16 |
										((unsigned char)text[3])<<8 | (unsigned char)text[4];
			break;

		default:
			Compiler_makeLexerError(compiler, "Invalid char size");
			return NULL;
	}

	return this;
}
//endregion




//region PROGRAM VALUE
void EulProgram_init(EulProgram* this, char* entryPoint) {
  //setup entry point file token
  EulToken* entryPointToken = malloc( sizeof(EulToken) );
  entryPointToken->type = EulTokenType_SOURCE_FILE;
  EulSourceFile_init(entryPointToken->value.asSourceFile, entryPoint);

  //push it in sources list
  EulNodeList_init(&this->sources);
  EulNodeList_push(&this->sources, entryPointToken);

  //save it as our "entry point"
  this->entryPoint = entryPointToken;
}


void EulProgram_deinit(EulProgram* this) {
  EulToken_deinit(this->sources.first->value);
  free(this->sources.first->value);
  EulNodeList_deinitAllNodes(&this->sources);
}


EulToken* EulProgram_getSource(EulProgram* this, char* id, char createIfNotExists) {
  if (id==0) return 0;

  //try finding the file
  EulNode *current = this->sources.first;
  while(current) {
    if (strcmp(id, current->value->value.asSourceFile->id)==0) return current->value;
    current = current->next;
  }

  //we did not find the token. What we should now do, depends on createIfNotExists.
  if (!createIfNotExists) return 0;

  //we create a token, add it on our list, and return it.
  EulToken* entryPointToken = malloc( sizeof(EulToken) );
  entryPointToken->type = EulTokenType_SOURCE_FILE;
  EulSourceFile_init(entryPointToken->value.asSourceFile, id);
  EulNodeList_push(&this->sources, entryPointToken);

  return entryPointToken;
}


/**
  Will be probably called by the Compiler object every time it needs to get the next source file.
  returns a token with type EulTokenType_SOURCE_FILE,
          null if all files are parsed.
*/
EulToken* EulProgram_nextPendingSource(EulProgram* this) {
  EulNode *current = this->sources.first;
  while(current) {
    if (current->value->value.asSourceFile->isParsed==0) return current->value;
    current = current->next;
  }

  //all files are parsed. return null.
  return 0;
}
//endregion




//region SOURCE FILE
void EulSourceFile_init(EulSourceFile* this, char* entryPoint) {
  this->isParsed = 0;
  EulNodeList_init(&this->imports);
  EulNodeList_init(&this->exports);
  EulNodeList_init(&this->symbols);
  EulNodeList_init(&this->statements);
}

void EulSourceFile_deinit(EulSourceFile* this) {
  EulNodeList_deinitAllNodes(&this->imports);
  EulNodeList_deinitAllNodes(&this->exports);
  EulNodeList_deinitAllNodes(&this->symbols);
  EulNodeList_deinitAllNodes(&this->statements);
}
//endregion
