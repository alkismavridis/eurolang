%option outfile="../src/lexer/autoGenerated.EulLexer.c" header-file="../src/lexer/autoGenerated.EulLexer.h"
%option reentrant
%option bison-bridge
%option noyywrap nounput
%option yylineno




%{
  #define YY_DECL int yylex(YYSTYPE * yylval_param, void* yyscanner, Compiler *compiler)
  #include "../parser/autoGenerated.EulSyntax.h"
  #include "../Compiler.h"
  #include "../Compiler.Functions.h"
  #include "../core/EulToken.Functions.h"
  #include "../lexer/LexerUtils.h"
%}







ASC     [\x00-\x7f]
ASCN    [\x00-\t\v-\x7f]
U       [\x80-\xbf]
U2      [\xc2-\xdf]
U3      [\xe0-\xef]
U4      [\xf0-\xf4]

ANY_UNICODE    			{ASC}|{U2}{U}|{U3}{U}{U}|{U4}{U}{U}{U}
ANY_UNICODE_NO_NL   {ASCN}|{U2}{U}|{U3}{U}{U}|{U4}{U}{U}{U}
NON_ASCII  					{U2}{U}|{U3}{U}{U}|{U4}{U}{U}{U}

WORD_TAIL	([a-zA-Z0-9_]|{NON_ASCII})



%%

[ \t]					;

[1-9][0-9]*([su][0-9]*)?			{ *yylval = malloc(sizeof(EulToken)); EulToken_initInt((EulToken*)(*yylval), yytext); return EulTokenType_INT; }
"0"([su][0-9]*)?							{ *yylval = malloc(sizeof(EulToken)); EulToken_initInt((EulToken*)(*yylval), yytext); return EulTokenType_INT; }

([0-9]+([.][0-9]*)?|[.][0-9]+)(f[0-9]*)?				{ *yylval = EulToken_newFloat(yytext); return EulTokenType_FLOAT; }


"if"					{ *yylval = 0; return EulTokenType_IF; }
"while"				{ *yylval = 0; return EulTokenType_WHILE; }
"for"					{ *yylval = 0; return EulTokenType_FOR; }
"var"					{ *yylval = 0; return EulTokenType_VAR; }
"val"					{ *yylval = 0; return EulTokenType_VAL; }


[a-zA-Z]{WORD_TAIL}*	{ *yylval = EulToken_newId(yytext, yyleng); return EulTokenType_ID; }



"+"			{ *yylval = 0; return EulTokenType_PLUS; }
"-"			{ *yylval = 0; return EulTokenType_MINUS; }
"~"			{ *yylval = 0; return EulTokenType_TILDE; }
"!"			{ *yylval = 0; return EulTokenType_NOT; }
"!="		{ *yylval = 0; 	return EulTokenType_NOT_EQUALS; }
"!=="		{ *yylval = 0; 	return EulTokenType_NOT_SAME; }
"@"			{ *yylval = 0; return EulTokenType_AT; }
"#"			{ *yylval = 0; return EulTokenType_HASH; }
"$"			{ *yylval = 0; return EulTokenType_DOLLAR; }
"%"			{ *yylval = 0; return EulTokenType_PERCENT; }
"%="			{ *yylval = 0; return EulTokenType_ASSIGN_MOD; }
"^"			{ *yylval = 0; return EulTokenType_XOR; }
"^="			{ *yylval = 0; return EulTokenType_ASSIGN_XOR; }
"&"			{ *yylval = 0; return EulTokenType_BIN_AND; }
"&&"			{ *yylval = 0; return EulTokenType_AND; }
"&="			{ *yylval = 0; return EulTokenType_ASSIGN_AND; }
"*"			{ *yylval = 0; return EulTokenType_STAR; }
"*="			{ *yylval = 0; return EulTokenType_ASSIGN_STAR; }
"("			{ *yylval = 0; return EulTokenType_PARENTHESIS_OPEN; }
")"			{ *yylval = 0; return EulTokenType_PARENTHESIS_CLOSE; }
"--"			{ *yylval = 0; return EulTokenType_DECREASE; }
"-="			{ *yylval = 0; return EulTokenType_ASSIGN_MINUS; }
"->"			{ *yylval = 0; return EulTokenType_ARROW; }
"="			{ *yylval = 0; return EulTokenType_ASSIGN; }
"=="			{ *yylval = 0; return EulTokenType_EQUALS; }
"==="			{ *yylval = 0; return EulTokenType_SAME; }
"++"			{ *yylval = 0; return EulTokenType_INCREASE; }
"+="			{ *yylval = 0; return EulTokenType_ASSIGN_PLUS; }
"["			{ *yylval = 0; return EulTokenType_SQUARE_OPEN; }
"]"			{ *yylval = 0; return EulTokenType_SQUARE_CLOSE; }
"{"			{ *yylval = 0; return EulTokenType_CURLY_OPEN; }
"}"			{ *yylval = 0; return EulTokenType_CURLY_CLOSE; }
"\\"			{ *yylval = 0; return EulTokenType_BACKSLASH; }
"|"			{ *yylval = 0; return EulTokenType_BIN_OR; }
"||"			{ *yylval = 0; return EulTokenType_OR; }
"|="			{ *yylval = 0; return EulTokenType_ASSIGN_OR; }
";"			{ *yylval = 0; return EulTokenType_SEMICOLON; }
":"			{ *yylval = 0; return EulTokenType_COLON; }
"/"			{ *yylval = 0; return EulTokenType_SLASH; }
"/="			{ *yylval = 0; return EulTokenType_ASSIGN_DIV; }
"?"		{ *yylval = 0; 	return EulTokenType_QUESTION; }
"."		{ *yylval = 0; 	return EulTokenType_DOT; }
","		{ *yylval = 0; 	return EulTokenType_COMMA; }
"<"			{ *yylval = 0; return EulTokenType_LESS; }
"<="			{ *yylval = 0; return EulTokenType_LESS_EQUALS; }
"<<"			{ *yylval = 0; return EulTokenType_LSHIFT; }
"<<="			{ *yylval = 0; return EulTokenType_ASSIGN_LSHIFT; }
">"			{ *yylval = 0; return EulTokenType_MORE; }
">="		{ *yylval = 0; 	return EulTokenType_MORE_EQUALS; }
">>"		{ *yylval = 0; 	return EulTokenType_RSHIFT; }
">>="		{ *yylval = 0; 	return EulTokenType_ASSIGN_RSHIFT; }
"\n"			{ *yylval = 0; return EulTokenType_NL; }



"\"" {
  *yylval = LexerUtils_parseStringValue(compiler);
  if (compiler->errorCode != ErrorType_NO_ERROR) return EulTokenType_ERROR;
  return EulTokenType_STRING;
}

"'\\" {
  *yylval = LexerUtils_parseEscapedChar(compiler);
  if (compiler->errorCode != ErrorType_NO_ERROR) return EulTokenType_ERROR;
  return EulTokenType_CHAR;
}

"'"{ANY_UNICODE}"'"	{
  *yylval = EulToken_newSimpleChar(yytext, yyleng, compiler);
  if (compiler->errorCode != ErrorType_NO_ERROR) return EulTokenType_ERROR;
  return EulTokenType_CHAR;
}

"/*"  {
  LexerUtils_skipMultiLineComment(compiler);
  if (compiler->errorCode != ErrorType_NO_ERROR) return EulTokenType_ERROR;
}

"//"	{
  LexerUtils_skipSingleLineComment(compiler);
  if (compiler->errorCode != ErrorType_NO_ERROR) return EulTokenType_ERROR;
  return EulTokenType_NL;
}



<<EOF>> return EulTokenType_EOF;

.	{
  Compiler_makeLexerError(compiler, "Unexpected character\n");
  return EulTokenType_ERROR;
}


%%


#include "../lexer/LexerUtils.implementation.h"
